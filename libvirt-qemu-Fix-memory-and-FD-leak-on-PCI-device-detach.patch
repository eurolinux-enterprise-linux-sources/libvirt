From b9139c144aeb2968debd912fe0ed3c38b3c26a02 Mon Sep 17 00:00:00 2001
Message-Id: <b9139c144aeb2968debd912fe0ed3c38b3c26a02.1354720508.git.jdenemar@redhat.com>
From: Jiri Denemark <jdenemar@redhat.com>
Date: Tue, 4 Dec 2012 09:18:44 +0100
Subject: [PATCH] qemu: Fix memory (and FD) leak on PCI device detach

https://bugzilla.redhat.com/show_bug.cgi?id=877095

Unmanaged PCI devices were only leaked if pciDeviceListAdd failed but
managed devices were always leaked. And leaking PCI device is likely to
leave PCI config file descriptor open. This patch fixes
qemuReattachPciDevice to either free the PCI device or add it to the
inactivePciHostdevs list.
(cherry picked from commit 6910318798d9dda9c20732bb7f7aba90e7871737)
---
 src/qemu/qemu_hostdev.c | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/src/qemu/qemu_hostdev.c b/src/qemu/qemu_hostdev.c
index a8d0755..66b010c 100644
--- a/src/qemu/qemu_hostdev.c
+++ b/src/qemu/qemu_hostdev.c
@@ -546,10 +546,8 @@ int qemuPrepareHostdevPCIDevices(struct qemud_driver *driver,
     }
 
     /* Loop 9: Now steal all the devices from pcidevs */
-    while (pciDeviceListCount(pcidevs) > 0) {
-        pciDevice *dev = pciDeviceListGet(pcidevs, 0);
-        pciDeviceListSteal(pcidevs, dev);
-    }
+    while (pciDeviceListCount(pcidevs) > 0)
+        pciDeviceListStealIndex(pcidevs, 0);
 
     ret = 0;
     goto cleanup;
@@ -818,7 +816,8 @@ void qemuReattachPciDevice(pciDevice *dev, struct qemud_driver *driver)
      * successfully, it must have been inactive.
      */
     if (!pciDeviceGetManaged(dev)) {
-        pciDeviceListAdd(driver->inactivePciHostdevs, dev);
+        if (pciDeviceListAdd(driver->inactivePciHostdevs, dev) < 0)
+            pciFreeDevice(dev);
         return;
     }
 
@@ -835,6 +834,7 @@ void qemuReattachPciDevice(pciDevice *dev, struct qemud_driver *driver)
                   err ? err->message : _("unknown error"));
         virResetError(err);
     }
+    pciFreeDevice(dev);
 }
 
 
@@ -905,8 +905,8 @@ void qemuDomainReAttachHostdevDevices(struct qemud_driver *driver,
         }
     }
 
-    for (i = 0; i < pciDeviceListCount(pcidevs); i++) {
-        pciDevice *dev = pciDeviceListGet(pcidevs, i);
+    while (pciDeviceListCount(pcidevs) > 0) {
+        pciDevice *dev = pciDeviceListStealIndex(pcidevs, 0);
         qemuReattachPciDevice(dev, driver);
     }
 
-- 
1.8.0

