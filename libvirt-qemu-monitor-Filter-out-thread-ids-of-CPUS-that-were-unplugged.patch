From 4a0d82c47d2e68297cf876d1b0c23d3132a0a6f8 Mon Sep 17 00:00:00 2001
Message-Id: <4a0d82c47d2e68297cf876d1b0c23d3132a0a6f8@dist-git>
From: Peter Krempa <pkrempa@redhat.com>
Date: Tue, 4 Mar 2014 16:45:57 +0100
Subject: [PATCH] qemu: monitor: Filter out thread ids of CPUS that were
 unplugged

RHEL-only (RHEL 6 only)

https://bugzilla.redhat.com/show_bug.cgi?id=1066473

The RHEL 6 downstream version of qemu now supports CPU hot-unplug but
after the CPU is removed from the guest the cpu thread isn't removed.
The thread is then reported via the "query-cpus" monitor command. This
makes libvirt think that the CPU wasn't unplugged as the thread still
exists.

This downstream patch uses a special new field in the ouptut of
"query-cpus" which tells us whether the cpu was disabled to filter out
unused threads.

Signed-off-by: Jiri Denemark <jdenemar@redhat.com>
---
 src/qemu/qemu_monitor_json.c | 43 +++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 41 insertions(+), 2 deletions(-)

diff --git a/src/qemu/qemu_monitor_json.c b/src/qemu/qemu_monitor_json.c
index de31665..4673c8e 100644
--- a/src/qemu/qemu_monitor_json.c
+++ b/src/qemu/qemu_monitor_json.c
@@ -1180,6 +1180,27 @@ int qemuMonitorJSONSystemReset(qemuMonitorPtr mon)
 /*
  * [ { "CPU": 0, "current": true, "halted": false, "pc": 3227107138 },
  *   { "CPU": 1, "current": false, "halted": true, "pc": 7108165 } ]
+ *
+ *   RHEL 6 only:
+ *
+ *   The downstream qemu version may report the state of the processor
+ *   in the "enabled-in-acpi" field. Disabled processors need to be
+ *   skipped as they are still tracked by qemu but not active.
+ *   The new field is optional. The format of the improved structure:
+ *
+ *   [ { "enabled-in-acpi" : true,
+ *       "current" : true,
+ *       "CPU" : 0,
+ *       "pc" : -2130449205,
+ *       "halted" : true,
+ *       "thread_id" : 19611 },
+ *     { "enabled-in-acpi" : false,
+ *       "current" : false,
+ *       "CPU" : 1,
+ *       "pc" : -2130505423,
+ *       "halted" : true,
+ *       "thread_id" : 19612 }
+ *   ]
  */
 static int
 qemuMonitorJSONExtractCPUInfo(virJSONValuePtr reply,
@@ -1190,6 +1211,7 @@ qemuMonitorJSONExtractCPUInfo(virJSONValuePtr reply,
     int i;
     int *threads = NULL;
     int ncpus;
+    int cpu = 0;
 
     if (!(data = virJSONValueObjectGet(reply, "return"))) {
         virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
@@ -1217,12 +1239,24 @@ qemuMonitorJSONExtractCPUInfo(virJSONValuePtr reply,
     for (i = 0 ; i < ncpus ; i++) {
         virJSONValuePtr entry = virJSONValueArrayGet(data, i);
         int thread;
+        bool enabled;
+
         if (!entry) {
             virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
                            _("cpu information was missing an array element"));
             goto cleanup;
         }
 
+        /* RHEL-only: use the "enabled-in-acpi" field of the returned structure
+         * to filter out processors that were disabled when doing cpu hot-unplug.
+         *
+         * This functionality will remain in the RHEL 6 series as upstream will
+         * go a different route */
+        if (virJSONValueObjectGetBoolean(entry, "enabled-in-acpi",
+                                         &enabled) == 0 &&
+            !enabled)
+            continue;
+
         if (virJSONValueObjectGetNumberInt(entry, "thread_id", &thread) < 0) {
             /* Some older qemu versions don't report the thread_id,
              * so treat this as non-fatal, simply returning no data */
@@ -1230,12 +1264,17 @@ qemuMonitorJSONExtractCPUInfo(virJSONValuePtr reply,
             goto cleanup;
         }
 
-        threads[i] = thread;
+        threads[cpu++] = thread;
+    }
+
+    if (VIR_REALLOC_N(threads, cpu) < 0) {
+        virReportOOMError();
+        goto cleanup;
     }
 
     *pids = threads;
     threads = NULL;
-    ret = ncpus;
+    ret = cpu;
 
 cleanup:
     VIR_FREE(threads);
-- 
1.9.1

