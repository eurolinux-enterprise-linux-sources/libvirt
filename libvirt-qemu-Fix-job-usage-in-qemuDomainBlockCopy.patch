From 1617c65d5c94af06ee83fd760b0a674e47e58eda Mon Sep 17 00:00:00 2001
Message-Id: <1617c65d5c94af06ee83fd760b0a674e47e58eda@dist-git>
From: Jiri Denemark <jdenemar@redhat.com>
Date: Fri, 17 Jan 2014 16:06:03 -0700
Subject: [PATCH] qemu: Fix job usage in qemuDomainBlockCopy

https://bugzilla.redhat.com/show_bug.cgi?id=1043069

API that is going to begin a job should do that before fetching
data from vm->def.

(cherry picked from commit ff5f30b6bfa317f2a4c33f69289baf4e887eb048)

Signed-off-by: Jiri Denemark <jdenemar@redhat.com>
---
 src/qemu/qemu_driver.c | 25 ++++++++++---------------
 1 file changed, 10 insertions(+), 15 deletions(-)

diff --git a/src/qemu/qemu_driver.c b/src/qemu/qemu_driver.c
index c45c756..5893c6b 100644
--- a/src/qemu/qemu_driver.c
+++ b/src/qemu/qemu_driver.c
@@ -13759,7 +13759,7 @@ qemuDomainBlockCopy(virDomainPtr dom, const char *path,
     virDomainObjPtr vm;
     qemuDomainObjPrivatePtr priv;
     char *device = NULL;
-    virDomainDiskDefPtr disk;
+    virDomainDiskDefPtr disk = NULL;
     int ret = -1;
     int idx;
     struct stat st;
@@ -13775,10 +13775,13 @@ qemuDomainBlockCopy(virDomainPtr dom, const char *path,
         goto cleanup;
     priv = vm->privateData;
 
+    if (qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) < 0)
+        goto cleanup;
+
     if (!virDomainObjIsActive(vm)) {
         virReportError(VIR_ERR_OPERATION_INVALID, "%s",
                        _("domain is not running"));
-        goto cleanup;
+        goto endjob;
     }
     if (qemuCgroupControllerActive(driver, VIR_CGROUP_CONTROLLER_DEVICES) &&
         virCgroupForDomain(driver->cgroup, vm->def->name, &cgroup, 0) < 0) {
@@ -13790,21 +13793,21 @@ qemuDomainBlockCopy(virDomainPtr dom, const char *path,
 
     device = qemuDiskPathToAlias(vm, path, &idx);
     if (!device) {
-        goto cleanup;
+        goto endjob;
     }
     disk = vm->def->disks[idx];
     if (disk->mirror) {
         virReportError(VIR_ERR_BLOCK_COPY_ACTIVE,
                        _("disk '%s' already in active block copy job"),
                        disk->dst);
-        goto cleanup;
+        goto endjob;
     }
 
     if (!(qemuCapsGet(priv->caps, QEMU_CAPS_DRIVE_MIRROR) &&
           qemuCapsGet(priv->caps, QEMU_CAPS_BLOCKJOB_ASYNC))) {
         virReportError(VIR_ERR_CONFIG_UNSUPPORTED, "%s",
                        _("block copy is not supported with this QEMU binary"));
-        goto cleanup;
+        goto endjob;
     }
     if (vm->persistent) {
         /* XXX if qemu ever lets us start a new domain with mirroring
@@ -13813,17 +13816,9 @@ qemuDomainBlockCopy(virDomainPtr dom, const char *path,
          * this on persistent domains.  */
         virReportError(VIR_ERR_OPERATION_INVALID, "%s",
                        _("domain is not transient"));
-        goto cleanup;
-    }
-
-    if (qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) < 0)
-        goto cleanup;
-
-    if (!virDomainObjIsActive(vm)) {
-        virReportError(VIR_ERR_OPERATION_INVALID, "%s",
-                       _("domain is not running"));
         goto endjob;
     }
+
     if (qemuDomainDetermineDiskChain(driver, disk, false) < 0)
         goto endjob;
 
@@ -13915,7 +13910,7 @@ qemuDomainBlockCopy(virDomainPtr dom, const char *path,
 endjob:
     if (need_unlink && unlink(dest))
         VIR_WARN("unable to unlink just-created %s", dest);
-    if (ret < 0)
+    if (ret < 0 && disk)
         disk->mirrorFormat = VIR_STORAGE_FILE_NONE;
     VIR_FREE(mirror);
     if (qemuDomainObjEndJob(driver, vm) == 0) {
-- 
1.9.1

