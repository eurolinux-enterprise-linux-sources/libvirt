From e2de3965b94ea2bd37b6b8edcd8ca2a29d3280b5 Mon Sep 17 00:00:00 2001
Message-Id: <e2de3965b94ea2bd37b6b8edcd8ca2a29d3280b5.1373271638.git.jdenemar@redhat.com>
From: Osier Yang <jyang@redhat.com>
Date: Mon, 11 Mar 2013 15:26:05 +0800
Subject: [PATCH] qemu: Record names of domain which uses the shared disk in
 hash table

https://bugzilla.redhat.com/show_bug.cgi?id=908073

The hash entry is changed from "ref" to {ref, @domains}. With this, the
caller can simply call qemuRemoveSharedDisk, without afraid of removing
the entry belongs to other domains. qemuProcessStart will obviously
benifit from it on error codepath (which calls qemuProcessStop to do
the cleanup).
(cherry picked from commit a4504ac184c8fa5c30856a58e2f26f1a5db3fb90)

Conflicts:
  * Conflicts with commit 8cdd5faf (Pass virQEMUDriverPtr into APIs managed
    shared disk list), which won't be backported to 6.4 for risks.

	src/qemu/qemu_conf.c
	src/qemu/qemu_conf.h
	src/qemu/qemu_driver.c
	src/qemu/qemu_process.c
---
 src/qemu/qemu_conf.c    | 167 ++++++++++++++++++++++++++++++++++++++++++------
 src/qemu/qemu_conf.h    |  21 ++++--
 src/qemu/qemu_driver.c  |   6 +-
 src/qemu/qemu_process.c |   4 +-
 4 files changed, 171 insertions(+), 27 deletions(-)

diff --git a/src/qemu/qemu_conf.c b/src/qemu/qemu_conf.c
index cfc1e37..ca46648 100644
--- a/src/qemu/qemu_conf.c
+++ b/src/qemu/qemu_conf.c
@@ -746,6 +746,11 @@ qemuDriverCloseCallbackRunAll(struct qemud_driver *driver,
     virHashForEach(driver->closeCallbacks, qemuDriverCloseCallbackRun, &data);
 }
 
+struct _qemuSharedDiskEntry {
+    size_t ref;
+    char **domains; /* array of domain names */
+};
+
 /* Construct the hash key for sharedDisks as "major:minor" */
 char *
 qemuGetSharedDiskKey(const char *disk_path)
@@ -780,10 +785,9 @@ static int
 qemuCheckSharedDisk(virHashTablePtr sharedDisks,
                     virDomainDiskDefPtr disk)
 {
-    int val;
-    size_t *ref = NULL;
     char *sysfs_path = NULL;
     char *key = NULL;
+    int val;
     int ret = 0;
 
     /* The only conflicts between shared disk we care about now
@@ -803,7 +807,6 @@ qemuCheckSharedDisk(virHashTablePtr sharedDisks,
     if (!virFileExists(sysfs_path))
         goto cleanup;
 
-
     if (!(key = qemuGetSharedDiskKey(disk->src))) {
         ret = -1;
         goto cleanup;
@@ -812,7 +815,7 @@ qemuCheckSharedDisk(virHashTablePtr sharedDisks,
     /* It can't be conflict if no other domain is
      * is sharing it.
      */
-    if (!(ref = virHashLookup(sharedDisks, key)))
+    if (!(virHashLookup(sharedDisks, key)))
         goto cleanup;
 
     if (virGetDeviceUnprivSGIO(disk->src, NULL, &val) < 0) {
@@ -838,14 +841,84 @@ cleanup:
     return ret;
 }
 
-/* Increase ref count if the entry already exists, otherwise
- * add a new entry.
+bool
+qemuSharedDiskEntryDomainExists(qemuSharedDiskEntryPtr entry,
+                                const char *name,
+                                int *idx)
+{
+    size_t i;
+
+    for (i = 0; i < entry->ref; i++) {
+        if (STREQ(entry->domains[i], name)) {
+            if (idx)
+                *idx = i;
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void
+qemuSharedDiskEntryFree(void *payload, const void *name ATTRIBUTE_UNUSED)
+{
+    qemuSharedDiskEntryPtr entry = payload;
+    size_t i;
+
+    for (i = 0; i < entry->ref; i++) {
+        VIR_FREE(entry->domains[i]);
+    }
+    VIR_FREE(entry->domains);
+    VIR_FREE(entry);
+}
+
+static qemuSharedDiskEntryPtr
+qemuSharedDiskEntryCopy(const qemuSharedDiskEntryPtr entry)
+{
+    qemuSharedDiskEntryPtr ret = NULL;
+    size_t i;
+
+    if (VIR_ALLOC(ret) < 0) {
+        virReportOOMError();
+        return NULL;
+    }
+
+    if (VIR_ALLOC_N(ret->domains, entry->ref) < 0) {
+        virReportOOMError();
+        goto cleanup;
+    }
+
+    for (i = 0; i < entry->ref; i++) {
+        if (!(ret->domains[i] = strdup(entry->domains[i]))) {
+            virReportOOMError();
+            goto cleanup;
+        }
+        ret->ref++;
+    }
+
+    return ret;
+
+cleanup:
+    qemuSharedDiskEntryFree(ret, NULL);
+    return NULL;
+}
+
+/* qemuAddSharedDisk:
+ * @driver: Pointer to qemu driver struct
+ * @disk: The disk def
+ * @name: The domain name
+ *
+ * Increase ref count and add the domain name into the list which
+ * records all the domains that use the shared disk if the entry
+ * already exists, otherwise add a new entry.
  */
 int
 qemuAddSharedDisk(virHashTablePtr sharedDisks,
-                  virDomainDiskDefPtr disk)
+                  virDomainDiskDefPtr disk,
+                  const char *name)
 {
-    size_t *ref = NULL;
+    qemuSharedDiskEntry *entry = NULL;
+    qemuSharedDiskEntry *new_entry = NULL;
     char *key = NULL;
     int ret = -1;
 
@@ -863,11 +936,40 @@ qemuAddSharedDisk(virHashTablePtr sharedDisks,
     if (!(key = qemuGetSharedDiskKey(disk->src)))
         goto cleanup;
 
-    if ((ref = virHashLookup(sharedDisks, key))) {
-        if (virHashUpdateEntry(sharedDisks, key, ++ref) < 0)
+    if ((entry = virHashLookup(sharedDisks, key))) {
+        /* Nothing to do if the shared disk is already recorded
+         * in the table.
+         */
+        if (qemuSharedDiskEntryDomainExists(entry, name, NULL)) {
+            ret = 0;
+            goto cleanup;
+        }
+
+        if (!(new_entry = qemuSharedDiskEntryCopy(entry)))
+            goto cleanup;
+
+        if ((VIR_EXPAND_N(new_entry->domains, new_entry->ref, 1) < 0) ||
+            !(new_entry->domains[new_entry->ref - 1] = strdup(name))) {
+            qemuSharedDiskEntryFree(new_entry, NULL);
+            virReportOOMError();
+            goto cleanup;
+        }
+
+        if (virHashUpdateEntry(sharedDisks, key, new_entry) < 0) {
+            qemuSharedDiskEntryFree(new_entry, NULL);
             goto cleanup;
+        }
     } else {
-        if (virHashAddEntry(sharedDisks, key, (void *)0x1))
+        if ((VIR_ALLOC(entry) < 0) ||
+            (VIR_ALLOC_N(entry->domains, 1) < 0) ||
+            !(entry->domains[0] = strdup(name))) {
+            virReportOOMError();
+            goto cleanup;
+        }
+
+        entry->ref = 1;
+
+        if (virHashAddEntry(sharedDisks, key, entry))
             goto cleanup;
     }
 
@@ -877,16 +979,25 @@ cleanup:
     return ret;
 }
 
-/* Decrease the ref count if the entry already exists, otherwise
- * remove the entry.
+/* qemuRemoveSharedDisk:
+ * @driver: Pointer to qemu driver struct
+ * @disk: The disk def
+ * @name: The domain name
+ *
+ * Decrease ref count and remove the domain name from the list which
+ * records all the domains that use the shared disk if ref is not 1,
+ * otherwise remove the entry.
  */
 int
 qemuRemoveSharedDisk(virHashTablePtr sharedDisks,
-                     virDomainDiskDefPtr disk)
+                     virDomainDiskDefPtr disk,
+                     const char *name)
 {
-    size_t *ref = NULL;
+    qemuSharedDiskEntryPtr entry = NULL;
+    qemuSharedDiskEntryPtr new_entry = NULL;
     char *key = NULL;
     int ret = -1;
+    int idx;
 
     if (disk->type != VIR_DOMAIN_DISK_TYPE_BLOCK ||
         !disk->shared || !disk->src)
@@ -895,12 +1006,32 @@ qemuRemoveSharedDisk(virHashTablePtr sharedDisks,
     if (!(key = qemuGetSharedDiskKey(disk->src)))
         goto cleanup;
 
-    if (!(ref = virHashLookup(sharedDisks, key)))
+    if (!(entry = virHashLookup(sharedDisks, key)))
+        goto cleanup;
+
+    /* Nothing to do if the shared disk is not recored in
+     * the table.
+     */
+    if (!qemuSharedDiskEntryDomainExists(entry, name, &idx)) {
+        ret = 0;
         goto cleanup;
+    }
+
+    if (entry->ref != 1) {
+        if (!(new_entry = qemuSharedDiskEntryCopy(entry)))
+            goto cleanup;
+
+        if (idx != new_entry->ref - 1)
+            memmove(&new_entry->domains[idx],
+                    &new_entry->domains[idx + 1],
+                    sizeof(*new_entry->domains) * (new_entry->ref - idx - 1));
 
-    if (ref != (void *)0x1) {
-        if (virHashUpdateEntry(sharedDisks, key, --ref) < 0)
+        VIR_SHRINK_N(new_entry->domains, new_entry->ref, 1);
+
+        if (virHashUpdateEntry(sharedDisks, key, new_entry) < 0){
+            qemuSharedDiskEntryFree(new_entry, NULL);
             goto cleanup;
+        }
     } else {
         if (virHashRemoveEntry(sharedDisks, key) < 0)
             goto cleanup;
diff --git a/src/qemu/qemu_conf.h b/src/qemu/qemu_conf.h
index bd5d0ae..f1da2bf 100644
--- a/src/qemu/qemu_conf.h
+++ b/src/qemu/qemu_conf.h
@@ -206,15 +206,28 @@ qemuDriverCloseCallback qemuDriverCloseCallbackGet(struct qemud_driver *driver,
 void qemuDriverCloseCallbackRunAll(struct qemud_driver *driver,
                                    virConnectPtr conn);
 
-int qemuAddSharedDisk(virHashTablePtr sharedDisks,
-                      virDomainDiskDefPtr disk)
+typedef struct _qemuSharedDiskEntry qemuSharedDiskEntry;
+typedef qemuSharedDiskEntry *qemuSharedDiskEntryPtr;
+
+bool qemuSharedDiskEntryDomainExists(qemuSharedDiskEntryPtr entry,
+                                     const char *name,
+                                     int *index)
     ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2);
 
+int qemuAddSharedDisk(virHashTablePtr sharedDisks,
+                      virDomainDiskDefPtr disk,
+                      const char *name)
+    ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2) ATTRIBUTE_NONNULL(3);
+
 int qemuRemoveSharedDisk(virHashTablePtr sharedDisks,
-                         virDomainDiskDefPtr disk)
-    ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2);
+                         virDomainDiskDefPtr disk,
+                         const char *name)
+    ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2) ATTRIBUTE_NONNULL(3);
 
 char * qemuGetSharedDiskKey(const char *disk_path)
     ATTRIBUTE_NONNULL(1);
 
+void qemuSharedDiskEntryFree(void *payload, const void *name)
+    ATTRIBUTE_NONNULL(1);
+
 #endif /* __QEMUD_CONF_H */
diff --git a/src/qemu/qemu_driver.c b/src/qemu/qemu_driver.c
index 4967180..f943d1d 100644
--- a/src/qemu/qemu_driver.c
+++ b/src/qemu/qemu_driver.c
@@ -784,7 +784,7 @@ qemudStartup(int privileged) {
     if ((qemu_driver->inactivePciHostdevs = pciDeviceListNew()) == NULL)
         goto error;
 
-    if (!(qemu_driver->sharedDisks = virHashCreate(30, NULL)))
+    if (!(qemu_driver->sharedDisks = virHashCreate(30, qemuSharedDiskEntryFree)))
         goto error;
 
     if (privileged) {
@@ -5985,7 +5985,7 @@ qemuDomainAttachDeviceDiskLive(virConnectPtr conn,
     }
 
     if (ret == 0) {
-        if (qemuAddSharedDisk(driver->sharedDisks, disk) < 0)
+        if (qemuAddSharedDisk(driver->sharedDisks, disk, vm->def->name) < 0)
             VIR_WARN("Failed to add disk '%s' to shared disk table",
                      disk->src);
 
@@ -6110,7 +6110,7 @@ qemuDomainDetachDeviceDiskLive(struct qemud_driver *driver,
     }
 
     if (ret == 0) {
-        if (qemuRemoveSharedDisk(driver->sharedDisks, disk) < 0)
+        if (qemuRemoveSharedDisk(driver->sharedDisks, disk, vm->def->name) < 0)
              VIR_WARN("Failed to remove disk '%s' from shared disk table",
                       disk->src);
     }
diff --git a/src/qemu/qemu_process.c b/src/qemu/qemu_process.c
index 7b6d1c5..f479d2a 100644
--- a/src/qemu/qemu_process.c
+++ b/src/qemu/qemu_process.c
@@ -3833,7 +3833,7 @@ int qemuProcessStart(virConnectPtr conn,
         if (vm->def->disks[i]->rawio == 1)
             virCommandAllowCap(cmd, CAP_SYS_RAWIO);
 
-        if (qemuAddSharedDisk(driver->sharedDisks, disk) < 0)
+        if (qemuAddSharedDisk(driver->sharedDisks, disk, vm->def->name) < 0)
             goto cleanup;
 
         if (qemuSetUnprivSGIO(disk) < 0)
@@ -4285,7 +4285,7 @@ void qemuProcessStop(struct qemud_driver *driver,
 
     for (i = 0; i < vm->def->ndisks; i++) {
         virDomainDiskDefPtr disk = vm->def->disks[i];
-        ignore_value(qemuRemoveSharedDisk(driver->sharedDisks, disk));
+        ignore_value(qemuRemoveSharedDisk(driver->sharedDisks, disk, vm->def->name));
     }
 
     /* Clear out dynamically assigned labels */
-- 
1.8.2.1

