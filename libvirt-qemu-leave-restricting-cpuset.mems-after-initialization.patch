From f0ecdd11d73f7e8fcfe09c9bb2bd9bc6531df593 Mon Sep 17 00:00:00 2001
Message-Id: <f0ecdd11d73f7e8fcfe09c9bb2bd9bc6531df593@dist-git>
From: Martin Kletzander <mkletzan@redhat.com>
Date: Wed, 16 Sep 2015 13:17:36 +0200
Subject: [PATCH] qemu: leave restricting cpuset.mems after initialization
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

When domain is started with numatune memory mode strict and the
nodeset does not include host NUMA node with DMA and DMA32 zones, KVM
initialization fails.  This is because cgroup restrict even kernel
allocations.  We are already doing numa_set_membind() which does the
same thing, only it does not restrict kernel allocations.

This patch leaves the userspace numa_set_membind() in place and moves
the cpuset.mems setting after the point where monitor comes up, but
before vcpu and emulator sub-groups are created.

Signed-off-by: Martin Kletzander <mkletzan@redhat.com>
(cherry picked from commit 7e72ac787848b7434c9359a57c1e2789d92350f8)
Signed-off-by: JÃ¡n Tomko <jtomko@redhat.com>

https://bugzilla.redhat.com/show_bug.cgi?id=1263263

Conflicts:
	src/qemu/qemu_cgroup.c - context
	src/qemu/qemu_cgroup.h - pointless copyright update (dropped)
	src/qemu/qemu_process.c - context
  It was also necessary to pass a pointer to the qemu_driver struct,
  as the patch storing the cgroups in domain's private data is not
  backported.
Signed-off-by: Jiri Denemark <jdenemar@redhat.com>
---
 src/qemu/qemu_cgroup.c  | 16 +++++++++++-----
 src/qemu/qemu_cgroup.h  |  6 ++++--
 src/qemu/qemu_process.c |  6 +++++-
 3 files changed, 20 insertions(+), 8 deletions(-)

diff --git a/src/qemu/qemu_cgroup.c b/src/qemu/qemu_cgroup.c
index e132640..116c84f 100644
--- a/src/qemu/qemu_cgroup.c
+++ b/src/qemu/qemu_cgroup.c
@@ -246,8 +246,7 @@ cleanup:
 
 
 int qemuSetupCgroup(struct qemud_driver *driver,
-                    virDomainObjPtr vm,
-                    virBitmapPtr nodemask)
+                    virDomainObjPtr vm)
 {
     virCgroupPtr cgroup = NULL;
     int rc;
@@ -466,9 +465,6 @@ int qemuSetupCgroup(struct qemud_driver *driver,
         virCgroupSetCpusetMemoryMigrate(cgroup, true) < 0)
         goto cleanup;
 
-    if (qemuSetupCpusetMems(driver, vm, nodemask) < 0)
-        goto cleanup;
-
 done:
     virCgroupFree(&cgroup);
 
@@ -482,6 +478,16 @@ cleanup:
     return -1;
 }
 
+
+int
+qemuSetupCgroupPostInit(struct qemud_driver *driver,
+                        virDomainObjPtr vm,
+                        virBitmapPtr nodemask)
+{
+    return qemuSetupCpusetMems(driver, vm, nodemask);
+}
+
+
 int qemuSetupCgroupVcpuBW(virCgroupPtr cgroup, unsigned long long period,
                           long long quota)
 {
diff --git a/src/qemu/qemu_cgroup.h b/src/qemu/qemu_cgroup.h
index ed5d757..72f3096 100644
--- a/src/qemu/qemu_cgroup.h
+++ b/src/qemu/qemu_cgroup.h
@@ -46,8 +46,10 @@ int qemuSetupHostUsbDeviceCgroup(usbDevice *dev,
                                  const char *path,
                                  void *opaque);
 int qemuSetupCgroup(struct qemud_driver *driver,
-                    virDomainObjPtr vm,
-                    virBitmapPtr nodemask);
+                    virDomainObjPtr vm);
+int qemuSetupCgroupPostInit(struct qemud_driver *driver,
+                            virDomainObjPtr vm,
+                            virBitmapPtr nodemask);
 int qemuSetupCgroupVcpuBW(virCgroupPtr cgroup,
                           unsigned long long period,
                           long long quota);
diff --git a/src/qemu/qemu_process.c b/src/qemu/qemu_process.c
index 7c8154e..8a7e230 100644
--- a/src/qemu/qemu_process.c
+++ b/src/qemu/qemu_process.c
@@ -3981,7 +3981,7 @@ int qemuProcessStart(virConnectPtr conn,
     hookData.nodemask = nodemask;
 
     VIR_DEBUG("Setting up domain cgroup (if required)");
-    if (qemuSetupCgroup(driver, vm, nodemask) < 0)
+    if (qemuSetupCgroup(driver, vm) < 0)
         goto cleanup;
 
     if (VIR_ALLOC(priv->monConfig) < 0) {
@@ -4202,6 +4202,10 @@ int qemuProcessStart(virConnectPtr conn,
         priv->agentError = true;
     }
 
+    VIR_DEBUG("Setting up post-init cgroup restrictions");
+    if (qemuSetupCgroupPostInit(driver, vm, nodemask) < 0)
+        goto cleanup;
+
     VIR_DEBUG("Detecting VCPU PIDs");
     if (qemuProcessDetectVcpuPIDs(driver, vm) < 0)
         goto cleanup;
-- 
2.6.2

