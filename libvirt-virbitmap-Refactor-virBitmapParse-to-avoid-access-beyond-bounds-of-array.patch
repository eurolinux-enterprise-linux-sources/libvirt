From a5fcac0a981af9a07f01c884e1a1f0e1f549d7d9 Mon Sep 17 00:00:00 2001
Message-Id: <a5fcac0a981af9a07f01c884e1a1f0e1f549d7d9.1377097597.git.jdenemar@redhat.com>
From: Peter Krempa <pkrempa@redhat.com>
Date: Fri, 16 Aug 2013 15:34:11 +0200
Subject: [PATCH] virbitmap: Refactor virBitmapParse to avoid access beyond
 bounds of array

The virBitmapParse function was calling virBitmapIsSet() function that
requires the caller to check the bounds of the bitmap without checking
them. This resulted into crashes when parsing a bitmap string that was
exceeding the bounds used as argument.

This patch refactors the function to use virBitmapSetBit without
checking if the bit is set (this function does the checks internally)
and then counts the bits in the bitmap afterwards (instead of keeping
track while parsing the string).

This patch also changes the "parse_error" label to a more common
"error".

The refactor should also get rid of the need to call sa_assert on the
returned variable as the callpath should allow coverity to infer the
possible return values.

Resolves: https://bugzilla.redhat.com/show_bug.cgi?id=997367

Thanks to Alex Jia for tracking down the issue. This issue is introduced
by commit 0fc8909.

(cherry picked from commit 47b9127e883677a0d60d767030a147450e919a25)
---
 src/util/bitmap.c | 38 +++++++++++++++-----------------------
 1 file changed, 15 insertions(+), 23 deletions(-)

diff --git a/src/util/bitmap.c b/src/util/bitmap.c
index 4a6b567..2f9fa0f 100644
--- a/src/util/bitmap.c
+++ b/src/util/bitmap.c
@@ -283,7 +283,6 @@ int virBitmapParse(const char *str,
                    virBitmapPtr *bitmap,
                    size_t bitmapSize)
 {
-    int ret = 0;
     bool neg = false;
     const char *cur;
     char *tmp;
@@ -315,12 +314,12 @@ int virBitmapParse(const char *str,
         }
 
         if (!c_isdigit(*cur))
-            goto parse_error;
+            goto error;
 
         if (virStrToLong_i(cur, &tmp, 10, &start) < 0)
-            goto parse_error;
+            goto error;
         if (start < 0)
-            goto parse_error;
+            goto error;
 
         cur = tmp;
 
@@ -328,35 +327,29 @@ int virBitmapParse(const char *str,
 
         if (*cur == ',' || *cur == 0 || *cur == sep) {
             if (neg) {
-                if (virBitmapIsSet(*bitmap, start)) {
-                    ignore_value(virBitmapClearBit(*bitmap, start));
-                    ret--;
-                }
+                if (virBitmapClearBit(*bitmap, start) < 0)
+                    goto error;
             } else {
-                if (!virBitmapIsSet(*bitmap, start)) {
-                    ignore_value(virBitmapSetBit(*bitmap, start));
-                    ret++;
-                }
+                if (virBitmapSetBit(*bitmap, start) < 0)
+                    goto error;
             }
         } else if (*cur == '-') {
             if (neg)
-                goto parse_error;
+                goto error;
 
             cur++;
             virSkipSpaces(&cur);
 
             if (virStrToLong_i(cur, &tmp, 10, &last) < 0)
-                goto parse_error;
+                goto error;
             if (last < start)
-                goto parse_error;
+                goto error;
 
             cur = tmp;
 
             for (i = start; i <= last; i++) {
-                if (!virBitmapIsSet(*bitmap, i)) {
-                    ignore_value(virBitmapSetBit(*bitmap, i));
-                    ret++;
-                }
+                if (virBitmapSetBit(*bitmap, i) < 0)
+                    goto error;
             }
 
             virSkipSpaces(&cur);
@@ -369,14 +362,13 @@ int virBitmapParse(const char *str,
         } else if(*cur == 0 || *cur == sep) {
             break;
         } else {
-            goto parse_error;
+            goto error;
         }
     }
 
-    sa_assert(ret >= 0);
-    return ret;
+    return virBitmapCountBits(*bitmap);
 
-parse_error:
+error:
     virBitmapFree(*bitmap);
     *bitmap = NULL;
     return -1;
-- 
1.8.3.2

