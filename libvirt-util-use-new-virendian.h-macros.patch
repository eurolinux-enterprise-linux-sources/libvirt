From 2779a34342027dff6d723da4a012c4220fc8f8be Mon Sep 17 00:00:00 2001
Message-Id: <2779a34342027dff6d723da4a012c4220fc8f8be.1373271637.git.jdenemar@redhat.com>
From: Eric Blake <eblake@redhat.com>
Date: Mon, 25 Feb 2013 16:21:48 -0700
Subject: [PATCH] util: use new virendian.h macros

https://bugzilla.redhat.com/show_bug.cgi?id=903248

This makes code easier to read, by avoiding lines longer than
80 columns and removing the repetition from the callers.

* src/util/virstoragefile.c (qedGetHeaderUL, qedGetHeaderULL):
Delete in favor of more generic macros.
(qcow2GetBackingStoreFormat, qcowXGetBackingStore)
(qedGetBackingStore, virStorageFileMatchesVersion)
(virStorageFileGetMetadataInternal): Use new macros.
* src/cpu/cpu_x86.c (x86VendorLoad): Likewise.
(cherry picked from commit 731ad692408fb05be5f4b6720ad2bf6c5812bad2)

Conflicts:
	src/cpu/cpu_x86.c - pulled in one hunk from 1c04f999
---
 src/cpu/cpu_x86.c       |  24 ++++-------
 src/util/storage_file.c | 109 ++++++++++--------------------------------------
 2 files changed, 30 insertions(+), 103 deletions(-)

diff --git a/src/cpu/cpu_x86.c b/src/cpu/cpu_x86.c
index e691c04..40aadeb 100644
--- a/src/cpu/cpu_x86.c
+++ b/src/cpu/cpu_x86.c
@@ -1,7 +1,7 @@
 /*
  * cpu_x86.c: CPU driver for CPUs with x86 compatible CPUID instruction
  *
- * Copyright (C) 2009-2011 Red Hat, Inc.
+ * Copyright (C) 2009-2011, 2013 Red Hat, Inc.
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -32,6 +32,7 @@
 #include "cpu_map.h"
 #include "cpu_x86.h"
 #include "buf.h"
+#include "virendian.h"
 
 
 #define VIR_FROM_THIS VIR_FROM_CPU
@@ -548,22 +549,13 @@ x86VendorLoad(xmlXPathContextPtr ctxt,
     }
 
     vendor->cpuid.function = 0;
-    vendor->cpuid.ebx = (string[0]       ) |
-                        (string[1]  <<  8) |
-                        (string[2]  << 16) |
-                        (string[3]  << 24);
-    vendor->cpuid.edx = (string[4]       ) |
-                        (string[5]  <<  8) |
-                        (string[6]  << 16) |
-                        (string[7]  << 24);
-    vendor->cpuid.ecx = (string[8]       ) |
-                        (string[9]  <<  8) |
-                        (string[10] << 16) |
-                        (string[11] << 24);
-
-    if (!map->vendors)
+    vendor->cpuid.ebx = virReadBufInt32LE(string);
+    vendor->cpuid.edx = virReadBufInt32LE(string + 4);
+    vendor->cpuid.ecx = virReadBufInt32LE(string + 8);
+
+    if (!map->vendors) {
         map->vendors = vendor;
-    else {
+    } else {
         vendor->next = map->vendors;
         map->vendors = vendor;
     }
diff --git a/src/util/storage_file.c b/src/util/storage_file.c
index f354693..862aa33 100644
--- a/src/util/storage_file.c
+++ b/src/util/storage_file.c
@@ -42,6 +42,7 @@
 #include "virfile.h"
 #include "c-ctype.h"
 #include "virhash.h"
+#include "virendian.h"
 
 #define VIR_FROM_THIS VIR_FROM_STORAGE
 
@@ -243,16 +244,8 @@ qcow2GetBackingStoreFormat(int *format,
      */
     while (offset < (buf_size-8) &&
            offset < (extension_end-8)) {
-        unsigned int magic =
-            (buf[offset] << 24) +
-            (buf[offset+1] << 16) +
-            (buf[offset+2] << 8) +
-            (buf[offset+3]);
-        unsigned int len =
-            (buf[offset+4] << 24) +
-            (buf[offset+5] << 16) +
-            (buf[offset+6] << 8) +
-            (buf[offset+7]);
+        unsigned int magic = virReadBufInt32BE(buf + offset);
+        unsigned int len = virReadBufInt32BE(buf + offset + 4);
 
         offset += 8;
 
@@ -300,20 +293,10 @@ qcowXGetBackingStore(char **res,
 
     if (buf_size < QCOWX_HDR_BACKING_FILE_OFFSET+8+4)
         return BACKING_STORE_INVALID;
-    offset = (((unsigned long long)buf[QCOWX_HDR_BACKING_FILE_OFFSET] << 56)
-              | ((unsigned long long)buf[QCOWX_HDR_BACKING_FILE_OFFSET+1] << 48)
-              | ((unsigned long long)buf[QCOWX_HDR_BACKING_FILE_OFFSET+2] << 40)
-              | ((unsigned long long)buf[QCOWX_HDR_BACKING_FILE_OFFSET+3] << 32)
-              | ((unsigned long long)buf[QCOWX_HDR_BACKING_FILE_OFFSET+4] << 24)
-              | ((unsigned long long)buf[QCOWX_HDR_BACKING_FILE_OFFSET+5] << 16)
-              | ((unsigned long long)buf[QCOWX_HDR_BACKING_FILE_OFFSET+6] << 8)
-              | buf[QCOWX_HDR_BACKING_FILE_OFFSET+7]); /* QCowHeader.backing_file_offset */
+    offset = virReadBufInt64BE(buf + QCOWX_HDR_BACKING_FILE_OFFSET);
     if (offset > buf_size)
         return BACKING_STORE_INVALID;
-    size = ((buf[QCOWX_HDR_BACKING_FILE_SIZE] << 24)
-            | (buf[QCOWX_HDR_BACKING_FILE_SIZE+1] << 16)
-            | (buf[QCOWX_HDR_BACKING_FILE_SIZE+2] << 8)
-            | buf[QCOWX_HDR_BACKING_FILE_SIZE+3]); /* QCowHeader.backing_file_size */
+    size = virReadBufInt32BE(buf + QCOWX_HDR_BACKING_FILE_SIZE);
     if (size == 0) {
         if (format)
             *format = VIR_STORAGE_FILE_NONE;
@@ -456,28 +439,6 @@ cleanup:
     return ret;
 }
 
-static unsigned long
-qedGetHeaderUL(const unsigned char *loc)
-{
-    return ( ((unsigned long)loc[3] << 24)
-           | ((unsigned long)loc[2] << 16)
-           | ((unsigned long)loc[1] << 8)
-           | ((unsigned long)loc[0] << 0));
-}
-
-static unsigned long long
-qedGetHeaderULL(const unsigned char *loc)
-{
-    return ( ((unsigned long long)loc[7] << 56)
-           | ((unsigned long long)loc[6] << 48)
-           | ((unsigned long long)loc[5] << 40)
-           | ((unsigned long long)loc[4] << 32)
-           | ((unsigned long long)loc[3] << 24)
-           | ((unsigned long long)loc[2] << 16)
-           | ((unsigned long long)loc[1] << 8)
-           | ((unsigned long long)loc[0] << 0));
-}
-
 static int
 qedGetBackingStore(char **res,
                    int *format,
@@ -491,7 +452,7 @@ qedGetBackingStore(char **res,
     /* Check if this image has a backing file */
     if (buf_size < QED_HDR_FEATURES_OFFSET+8)
         return BACKING_STORE_INVALID;
-    flags = qedGetHeaderULL(buf + QED_HDR_FEATURES_OFFSET);
+    flags = virReadBufInt64LE(buf + QED_HDR_FEATURES_OFFSET);
     if (!(flags & QED_F_BACKING_FILE)) {
         *format = VIR_STORAGE_FILE_NONE;
         return BACKING_STORE_OK;
@@ -500,10 +461,10 @@ qedGetBackingStore(char **res,
     /* Parse the backing file */
     if (buf_size < QED_HDR_BACKING_FILE_OFFSET+8)
         return BACKING_STORE_INVALID;
-    offset = qedGetHeaderUL(buf + QED_HDR_BACKING_FILE_OFFSET);
+    offset = virReadBufInt32LE(buf + QED_HDR_BACKING_FILE_OFFSET);
     if (offset > buf_size)
         return BACKING_STORE_INVALID;
-    size = qedGetHeaderUL(buf + QED_HDR_BACKING_FILE_SIZE);
+    size = virReadBufInt32LE(buf + QED_HDR_BACKING_FILE_SIZE);
     if (size == 0)
         return BACKING_STORE_OK;
     if (offset + size > buf_size || offset + size < offset)
@@ -619,19 +580,10 @@ virStorageFileMatchesVersion(int format,
     if ((fileTypeInfo[format].versionOffset + 4) > buflen)
         return false;
 
-    if (fileTypeInfo[format].endian == LV_LITTLE_ENDIAN) {
-        version =
-            (buf[fileTypeInfo[format].versionOffset+3] << 24) |
-            (buf[fileTypeInfo[format].versionOffset+2] << 16) |
-            (buf[fileTypeInfo[format].versionOffset+1] << 8) |
-            (buf[fileTypeInfo[format].versionOffset]);
-    } else {
-        version =
-            (buf[fileTypeInfo[format].versionOffset] << 24) |
-            (buf[fileTypeInfo[format].versionOffset+1] << 16) |
-            (buf[fileTypeInfo[format].versionOffset+2] << 8) |
-            (buf[fileTypeInfo[format].versionOffset+3]);
-    }
+    if (fileTypeInfo[format].endian == LV_LITTLE_ENDIAN)
+        version = virReadBufInt32LE(buf + fileTypeInfo[format].versionOffset);
+    else
+        version = virReadBufInt32BE(buf + fileTypeInfo[format].versionOffset);
 
     VIR_DEBUG("Compare detected version %d vs expected version %d",
               version, fileTypeInfo[format].versionNumber);
@@ -673,29 +625,15 @@ virStorageFileGetMetadataFromBuf(int format,
         if ((fileTypeInfo[format].sizeOffset + 8) > buflen)
             return 1;
 
-        if (fileTypeInfo[format].endian == LV_LITTLE_ENDIAN) {
-            meta->capacity =
-                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+7] << 56) |
-                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+6] << 48) |
-                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+5] << 40) |
-                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+4] << 32) |
-                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+3] << 24) |
-                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+2] << 16) |
-                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+1] << 8) |
-                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset]);
-        } else {
-            meta->capacity =
-                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset] << 56) |
-                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+1] << 48) |
-                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+2] << 40) |
-                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+3] << 32) |
-                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+4] << 24) |
-                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+5] << 16) |
-                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+6] << 8) |
-                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+7]);
-        }
+        if (fileTypeInfo[format].endian == LV_LITTLE_ENDIAN)
+            meta->capacity = virReadBufInt64LE(buf +
+                                               fileTypeInfo[format].sizeOffset);
+        else
+            meta->capacity = virReadBufInt64BE(buf +
+                                               fileTypeInfo[format].sizeOffset);
         /* Avoid unlikely, but theoretically possible overflow */
-        if (meta->capacity > (ULLONG_MAX / fileTypeInfo[format].sizeMultiplier))
+        if (meta->capacity > (ULLONG_MAX /
+                              fileTypeInfo[format].sizeMultiplier))
             return 1;
         meta->capacity *= fileTypeInfo[format].sizeMultiplier;
     }
@@ -703,11 +641,8 @@ virStorageFileGetMetadataFromBuf(int format,
     if (fileTypeInfo[format].qcowCryptOffset != -1) {
         int crypt_format;
 
-        crypt_format =
-            (buf[fileTypeInfo[format].qcowCryptOffset] << 24) |
-            (buf[fileTypeInfo[format].qcowCryptOffset+1] << 16) |
-            (buf[fileTypeInfo[format].qcowCryptOffset+2] << 8) |
-            (buf[fileTypeInfo[format].qcowCryptOffset+3]);
+        crypt_format = virReadBufInt32BE(buf +
+                                         fileTypeInfo[format].qcowCryptOffset);
         meta->encrypted = crypt_format != 0;
     }
 
-- 
1.8.2.1

