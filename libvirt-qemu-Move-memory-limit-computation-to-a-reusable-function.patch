From 8942453afdd4a184ead0cb3620acbcdde18dbec1 Mon Sep 17 00:00:00 2001
Message-Id: <8942453afdd4a184ead0cb3620acbcdde18dbec1.1374158623.git.jdenemar@redhat.com>
From: Jiri Denemark <jdenemar@redhat.com>
Date: Fri, 28 Jun 2013 16:16:44 +0200
Subject: [PATCH] qemu: Move memory limit computation to a reusable function

https://bugzilla.redhat.com/show_bug.cgi?id=947118

(cherry picked from commit e0e438af00ef13f56ca73fbfb966146827e49ff3)

Conflicts:
	src/qemu/qemu_cgroup.c - context
	src/qemu/qemu_domain.h - context
---
 src/qemu/qemu_cgroup.c | 20 ++------------------
 src/qemu/qemu_domain.c | 33 +++++++++++++++++++++++++++++++++
 src/qemu/qemu_domain.h |  2 ++
 3 files changed, 37 insertions(+), 18 deletions(-)

diff --git a/src/qemu/qemu_cgroup.c b/src/qemu/qemu_cgroup.c
index c336934..e4a5452 100644
--- a/src/qemu/qemu_cgroup.c
+++ b/src/qemu/qemu_cgroup.c
@@ -343,24 +343,8 @@ int qemuSetupCgroup(struct qemud_driver *driver,
     }
 
     if (qemuCgroupControllerActive(driver, VIR_CGROUP_CONTROLLER_MEMORY)) {
-        unsigned long long hard_limit = vm->def->mem.hard_limit;
-
-        if (!hard_limit) {
-            /* If there is no hard_limit set, set a reasonable one to avoid
-             * system trashing caused by exploited qemu.  As 'reasonable limit'
-             * has been chosen:
-             *     (1 + k) * (domain memory + total video memory) + (32MB for
-             *     cache per each disk) + F
-             * where k = 0.5 and F = 200MB.  The cache for disks is important as
-             * kernel cache on the host side counts into the RSS limit. */
-            hard_limit = vm->def->mem.max_balloon;
-            for (i = 0; i < vm->def->nvideos; i++)
-                hard_limit += vm->def->videos[i]->vram;
-            hard_limit = hard_limit * 1.5 + 204800;
-            hard_limit += vm->def->ndisks * 32768;
-        }
-
-        rc = virCgroupSetMemoryHardLimit(cgroup, hard_limit);
+        rc = virCgroupSetMemoryHardLimit(cgroup,
+                                         qemuDomainMemoryLimit(vm->def));
         if (rc != 0) {
             virReportSystemError(-rc,
                                  _("Unable to set memory hard limit for domain %s"),
diff --git a/src/qemu/qemu_domain.c b/src/qemu/qemu_domain.c
index 654f69c..faf4a73 100644
--- a/src/qemu/qemu_domain.c
+++ b/src/qemu/qemu_domain.c
@@ -2030,3 +2030,36 @@ qemuDomainDetermineDiskChain(struct qemud_driver *driver,
         return -1;
     return 0;
 }
+
+
+unsigned long long
+qemuDomainMemoryLimit(virDomainDefPtr def)
+{
+    unsigned long long mem;
+    int i;
+
+    if (def->mem.hard_limit) {
+        mem = def->mem.hard_limit;
+    } else {
+        /* If there is no hard_limit set, compute a reasonable one to avoid
+         * system thrashing caused by exploited qemu.  A 'reasonable
+         * limit' has been chosen:
+         *     (1 + k) * (domain memory + total video memory) + (32MB for
+         *     cache per each disk) + F
+         * where k = 0.5 and F = 200MB.  The cache for disks is important as
+         * kernel cache on the host side counts into the RSS limit.
+         *
+         * Technically, the disk cache does not have to be included in
+         * RLIMIT_MEMLOCK but it doesn't hurt as it's just an upper limit and
+         * it makes this function and its usage simpler.
+         */
+        mem = def->mem.max_balloon;
+        for (i = 0; i < def->nvideos; i++)
+            mem += def->videos[i]->vram;
+        mem *= 1.5;
+        mem += def->ndisks * 32768;
+        mem += 204800;
+    }
+
+    return mem;
+}
diff --git a/src/qemu/qemu_domain.h b/src/qemu/qemu_domain.h
index 7e0e27c..5056d8c 100644
--- a/src/qemu/qemu_domain.h
+++ b/src/qemu/qemu_domain.h
@@ -364,4 +364,6 @@ void qemuDomainCleanupRemove(virDomainObjPtr vm,
 void qemuDomainCleanupRun(struct qemud_driver *driver,
                           virDomainObjPtr vm);
 
+unsigned long long qemuDomainMemoryLimit(virDomainDefPtr def);
+
 #endif /* __QEMU_DOMAIN_H__ */
-- 
1.8.3.2

