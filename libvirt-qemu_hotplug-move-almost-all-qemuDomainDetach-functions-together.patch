From efbfb47fa2b48ea4879a8897a2613963658adb89 Mon Sep 17 00:00:00 2001
Message-Id: <efbfb47fa2b48ea4879a8897a2613963658adb89@dist-git>
From: Laine Stump <laine@laine.org>
Date: Thu, 11 Apr 2019 15:14:38 -0400
Subject: [PATCH] qemu_hotplug: move (almost) all qemuDomainDetach*() functions
 together

There were two outliers at the end of the file beyond the Vcpu
functions.

Signed-off-by: Laine Stump <laine@laine.org>
ACKed-by: Peter Krempa <pkrempa@redhat.com>
(cherry picked from commit 5a8ffaec768ce25ef74eb398968e0b84b878a249)

Partially-Resolves: https://bugzilla.redhat.com/1658198
Signed-off-by: Laine Stump <laine@redhat.com>
Signed-off-by: Laine Stump <laine@laine.org>
Message-Id: <20190411191453.24055-27-laine@redhat.com>
Acked-by: Michal Privoznik <mprivozn@redhat.com>
---
 src/qemu/qemu_hotplug.c | 174 ++++++++++++++++++++--------------------
 1 file changed, 87 insertions(+), 87 deletions(-)

diff --git a/src/qemu/qemu_hotplug.c b/src/qemu/qemu_hotplug.c
index d80b9b005b..77237a895e 100644
--- a/src/qemu/qemu_hotplug.c
+++ b/src/qemu/qemu_hotplug.c
@@ -5547,6 +5547,93 @@ qemuDomainDetachMemoryDevice(virQEMUDriverPtr driver,
 }
 
 
+int
+qemuDomainDetachInputDevice(virDomainObjPtr vm,
+                            virDomainInputDefPtr def,
+                            bool async)
+{
+    virDomainInputDefPtr input;
+    int ret = -1;
+    int idx;
+
+    if ((idx = virDomainInputDefFind(vm->def, def)) < 0) {
+        virReportError(VIR_ERR_OPERATION_FAILED, "%s",
+                       _("matching input device not found"));
+        return -1;
+    }
+    input = vm->def->inputs[idx];
+
+    switch ((virDomainInputBus) input->bus) {
+    case VIR_DOMAIN_INPUT_BUS_PS2:
+    case VIR_DOMAIN_INPUT_BUS_XEN:
+    case VIR_DOMAIN_INPUT_BUS_PARALLELS:
+        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,
+                       _("input device on bus '%s' cannot be detached"),
+                       virDomainInputBusTypeToString(input->bus));
+        return -1;
+
+    case VIR_DOMAIN_INPUT_BUS_LAST:
+    case VIR_DOMAIN_INPUT_BUS_USB:
+    case VIR_DOMAIN_INPUT_BUS_VIRTIO:
+        break;
+    }
+
+    if (!async)
+        qemuDomainMarkDeviceForRemoval(vm, &input->info);
+
+    if (qemuDomainDeleteDevice(vm, input->info.alias) < 0)
+        goto cleanup;
+
+    if (async) {
+        ret = 0;
+    } else {
+        if ((ret = qemuDomainWaitForDeviceRemoval(vm)) == 1)
+            ret = qemuDomainRemoveInputDevice(vm, input);
+    }
+
+ cleanup:
+    if (!async)
+        qemuDomainResetDeviceRemoval(vm);
+    return ret;
+}
+
+
+int
+qemuDomainDetachVsockDevice(virDomainObjPtr vm,
+                            virDomainVsockDefPtr dev,
+                            bool async)
+{
+    virDomainVsockDefPtr vsock = vm->def->vsock;
+    int ret = -1;
+
+
+    if (!vsock ||
+        !virDomainVsockDefEquals(dev, vsock)) {
+        virReportError(VIR_ERR_OPERATION_FAILED, "%s",
+                       _("matching vsock device not found"));
+        return -1;
+    }
+
+    if (!async)
+        qemuDomainMarkDeviceForRemoval(vm, &vsock->info);
+
+    if (qemuDomainDeleteDevice(vm, vsock->info.alias) < 0)
+        goto cleanup;
+
+    if (async) {
+        ret = 0;
+    } else {
+        if ((ret = qemuDomainWaitForDeviceRemoval(vm)) == 1)
+            ret = qemuDomainRemoveVsockDevice(vm, vsock);
+    }
+
+ cleanup:
+    if (!async)
+        qemuDomainResetDeviceRemoval(vm);
+    return ret;
+}
+
+
 static int
 qemuDomainRemoveVcpu(virQEMUDriverPtr driver,
                      virDomainObjPtr vm,
@@ -6200,90 +6287,3 @@ qemuDomainSetVcpuInternal(virQEMUDriverPtr driver,
     virObjectUnref(cfg);
     return ret;
 }
-
-
-int
-qemuDomainDetachInputDevice(virDomainObjPtr vm,
-                            virDomainInputDefPtr def,
-                            bool async)
-{
-    virDomainInputDefPtr input;
-    int ret = -1;
-    int idx;
-
-    if ((idx = virDomainInputDefFind(vm->def, def)) < 0) {
-        virReportError(VIR_ERR_OPERATION_FAILED, "%s",
-                       _("matching input device not found"));
-        return -1;
-    }
-    input = vm->def->inputs[idx];
-
-    switch ((virDomainInputBus) input->bus) {
-    case VIR_DOMAIN_INPUT_BUS_PS2:
-    case VIR_DOMAIN_INPUT_BUS_XEN:
-    case VIR_DOMAIN_INPUT_BUS_PARALLELS:
-        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,
-                       _("input device on bus '%s' cannot be detached"),
-                       virDomainInputBusTypeToString(input->bus));
-        return -1;
-
-    case VIR_DOMAIN_INPUT_BUS_LAST:
-    case VIR_DOMAIN_INPUT_BUS_USB:
-    case VIR_DOMAIN_INPUT_BUS_VIRTIO:
-        break;
-    }
-
-    if (!async)
-        qemuDomainMarkDeviceForRemoval(vm, &input->info);
-
-    if (qemuDomainDeleteDevice(vm, input->info.alias) < 0)
-        goto cleanup;
-
-    if (async) {
-        ret = 0;
-    } else {
-        if ((ret = qemuDomainWaitForDeviceRemoval(vm)) == 1)
-            ret = qemuDomainRemoveInputDevice(vm, input);
-    }
-
- cleanup:
-    if (!async)
-        qemuDomainResetDeviceRemoval(vm);
-    return ret;
-}
-
-
-int
-qemuDomainDetachVsockDevice(virDomainObjPtr vm,
-                            virDomainVsockDefPtr dev,
-                            bool async)
-{
-    virDomainVsockDefPtr vsock = vm->def->vsock;
-    int ret = -1;
-
-
-    if (!vsock ||
-        !virDomainVsockDefEquals(dev, vsock)) {
-        virReportError(VIR_ERR_OPERATION_FAILED, "%s",
-                       _("matching vsock device not found"));
-        return -1;
-    }
-
-    if (!async)
-        qemuDomainMarkDeviceForRemoval(vm, &vsock->info);
-
-    if (qemuDomainDeleteDevice(vm, vsock->info.alias) < 0)
-        goto cleanup;
-
-    if (async) {
-        ret = 0;
-    } else {
-        if ((ret = qemuDomainWaitForDeviceRemoval(vm)) == 1)
-            ret = qemuDomainRemoveVsockDevice(vm, vsock);
-    }
-
- cleanup:
-    if (!async)
-        qemuDomainResetDeviceRemoval(vm);
-    return ret;
-}
-- 
2.21.0

