From c7645901fae15dfb39a35d9f896fa30ccc893feb Mon Sep 17 00:00:00 2001
Message-Id: <c7645901fae15dfb39a35d9f896fa30ccc893feb.1352118320.git.jdenemar@redhat.com>
From: Michal Privoznik <mprivozn@redhat.com>
Date: Thu, 1 Nov 2012 17:05:28 +0100
Subject: [PATCH] qemu: Report errors from iohelper

https://bugzilla.redhat.com/show_bug.cgi?id=866369

Currently, we use iohelper when saving/restoring a domain.
However, if there's some kind of error (like I/O) it is not
propagated to libvirt. Since it is not qemu who is doing
the actual write() it will not get error. The iohelper does.
Therefore we should check for iohelper errors as it makes
libvirt more user friendly.
(cherry picked from commit 34e8f63a32f830e23472dd2056e3c5a48d0c5710)
---
 src/libvirt_private.syms |  1 +
 src/qemu/qemu_driver.c   |  7 +++-
 src/util/virfile.c       | 99 ++++++++++++++++++++++++++++++++++++++++++++++++
 src/util/virfile.h       |  2 +
 4 files changed, 107 insertions(+), 2 deletions(-)

diff --git a/src/libvirt_private.syms b/src/libvirt_private.syms
index 410d6f0..859ea61 100644
--- a/src/libvirt_private.syms
+++ b/src/libvirt_private.syms
@@ -1332,6 +1332,7 @@ virDomainListSnapshots;
 virFileLoopDeviceAssociate;
 virFileClose;
 virFileDirectFdFlag;
+virFileWrapperFdCatchError;
 virFileWrapperFdClose;
 virFileWrapperFdFree;
 virFileWrapperFdNew;
diff --git a/src/qemu/qemu_driver.c b/src/qemu/qemu_driver.c
index de986da..901416e 100644
--- a/src/qemu/qemu_driver.c
+++ b/src/qemu/qemu_driver.c
@@ -2936,6 +2936,7 @@ endjob:
                 if (rc < 0)
                     VIR_WARN("Unable to resume guest CPUs after save failure");
             }
+            virFileWrapperFdCatchError(wrapperFd);
         }
         if (qemuDomainObjEndAsyncJob(driver, vm) == 0)
             vm = NULL;
@@ -3273,9 +3274,11 @@ doCoreDump(struct qemud_driver *driver,
 
 cleanup:
     VIR_FORCE_CLOSE(fd);
-    virFileWrapperFdFree(wrapperFd);
-    if (ret != 0)
+    if (ret != 0) {
+        virFileWrapperFdCatchError(wrapperFd);
         unlink(path);
+    }
+    virFileWrapperFdFree(wrapperFd);
     return ret;
 }
 
diff --git a/src/util/virfile.c b/src/util/virfile.c
index 5b00ead..9593151 100644
--- a/src/util/virfile.c
+++ b/src/util/virfile.c
@@ -135,10 +135,58 @@ virFileDirectFdFlag(void)
  * read-write is not supported, just a single direction.  */
 struct _virFileWrapperFd {
     virCommandPtr cmd; /* Child iohelper process to do the I/O.  */
+    int err_fd; /* FD to read stderr of @cmd */
+    char *err_msg; /* stderr of @cmd */
+    size_t err_msg_len; /* strlen of err_msg so we don't
+                           have to compute it every time */
+    int err_watch; /* ID of watch in the event loop */
 };
 
 #ifndef WIN32
 /**
+ * virFileWrapperFdReadStdErr:
+ * @watch: watch ID
+ * @fd: the read end of pipe to iohelper's stderr
+ * @events: an OR-ed set of events which occurred on @fd
+ * @opaque: virFileWrapperFdPtr
+ *
+ * This is a callback to our eventloop which will read iohelper's
+ * stderr, reallocate @opaque->err_msg and copy data.
+ */
+static void
+virFileWrapperFdReadStdErr(int watch ATTRIBUTE_UNUSED,
+                           int fd, int events, void *opaque)
+{
+    virFileWrapperFdPtr wfd = (virFileWrapperFdPtr) opaque;
+    char ebuf[1024];
+    ssize_t nread;
+
+    if (events & VIR_EVENT_HANDLE_READABLE) {
+        while ((nread = saferead(fd, ebuf, sizeof(ebuf)))) {
+            if (nread < 0) {
+                if (errno != EAGAIN)
+                    virReportSystemError(errno, "%s",
+                                         _("unable to read iohelper's stderr"));
+                break;
+            }
+
+            if (VIR_REALLOC_N(wfd->err_msg, wfd->err_msg_len + nread + 1) < 0) {
+                virReportOOMError();
+                return;
+            }
+            memcpy(wfd->err_msg + wfd->err_msg_len, ebuf, nread);
+            wfd->err_msg_len += nread;
+            wfd->err_msg[wfd->err_msg_len] = '\0';
+        }
+    }
+
+    if (events & VIR_EVENT_HANDLE_HANGUP) {
+        virEventRemoveHandle(watch);
+        wfd->err_watch = -1;
+    }
+}
+
+/**
  * virFileWrapperFdNew:
  * @fd: pointer to fd to wrap
  * @name: name of fd, for diagnostics
@@ -197,6 +245,8 @@ virFileWrapperFdNew(int *fd, const char *name, unsigned int flags)
         return NULL;
     }
 
+    ret->err_watch = -1;
+
     mode = fcntl(*fd, F_GETFL);
 
     if (mode < 0) {
@@ -229,9 +279,38 @@ virFileWrapperFdNew(int *fd, const char *name, unsigned int flags)
         virCommandAddArg(ret->cmd, "0");
     }
 
+    /* In order to catch iohelper stderr, we must:
+     * - pass a FD to virCommand (-1 to auto-allocate one)
+     * - change iohelper's env so virLog functions print to stderr
+     */
+    ret->err_fd = -1;
+    virCommandSetErrorFD(ret->cmd, &ret->err_fd);
+    virCommandAddEnvPair(ret->cmd, "LIBVIRT_LOG_OUTPUTS", "1:stderr");
+
     if (virCommandRunAsync(ret->cmd, NULL) < 0)
         goto error;
 
+    /* deliberately don't use virCommandNonblockingFDs here as it is all or
+     * nothing. And we want iohelper's stdin and stdout to block (default).
+     * However, stderr is read within event loop and therefore it must be
+     * nonblocking.*/
+    if (virSetNonBlock(ret->err_fd) < 0) {
+        virReportSystemError(errno, "%s",
+                             _("Failed to set non-blocking "
+                               "file descriptor flag"));
+        goto error;
+    }
+
+    if ((ret->err_watch = virEventAddHandle(ret->err_fd,
+                                            VIR_EVENT_HANDLE_READABLE,
+                                            virFileWrapperFdReadStdErr,
+                                            ret, NULL)) < 0) {
+        virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
+                       _("unable to register iohelper's "
+                         "stderr FD in the eventloop"));
+        goto error;
+    }
+
     if (VIR_CLOSE(pipefd[!output]) < 0) {
         virReportError(VIR_ERR_INTERNAL_ERROR, "%s", _("unable to close pipe"));
         goto error;
@@ -280,6 +359,21 @@ virFileWrapperFdClose(virFileWrapperFdPtr wfd)
     return virCommandWait(wfd->cmd, NULL);
 }
 
+
+/**
+ * virFileWrapperFdCatchError:
+ * @wfd: fd wrapper, or NULL
+ *
+ * If iohelper reported any error VIR_WARN() about it.
+ */
+void
+virFileWrapperFdCatchError(virFileWrapperFdPtr wfd)
+{
+    if (wfd->err_msg)
+        VIR_WARN("iohelper reports: %s", wfd->err_msg);
+}
+
+
 /**
  * virFileWrapperFdFree:
  * @wfd: fd wrapper, or NULL
@@ -295,6 +389,11 @@ virFileWrapperFdFree(virFileWrapperFdPtr wfd)
     if (!wfd)
         return;
 
+    VIR_FORCE_CLOSE(wfd->err_fd);
+    if (wfd->err_watch != -1)
+        virEventRemoveHandle(wfd->err_watch);
+    VIR_FREE(wfd->err_msg);
+
     virCommandFree(wfd->cmd);
     VIR_FREE(wfd);
 }
diff --git a/src/util/virfile.h b/src/util/virfile.h
index c885b73..80daf86 100644
--- a/src/util/virfile.h
+++ b/src/util/virfile.h
@@ -90,6 +90,8 @@ int virFileWrapperFdClose(virFileWrapperFdPtr dfd);
 
 void virFileWrapperFdFree(virFileWrapperFdPtr dfd);
 
+void virFileWrapperFdCatchError(virFileWrapperFdPtr dfd);
+
 int virFileLock(int fd, bool shared, off_t start, off_t len);
 int virFileUnlock(int fd, off_t start, off_t len);
 
-- 
1.8.0

