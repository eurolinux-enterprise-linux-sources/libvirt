From 2c8dd2aeb8d9dfd42518bea70ddfc91e4f97e76d Mon Sep 17 00:00:00 2001
Message-Id: <2c8dd2aeb8d9dfd42518bea70ddfc91e4f97e76d@dist-git>
From: Michal Privoznik <mprivozn@redhat.com>
Date: Wed, 14 May 2014 16:12:18 +0200
Subject: [PATCH] network: Introduce network hooks

https://bugzilla.redhat.com/show_bug.cgi?id=1064831

There might be some use cases, where user wants to prepare the host or
its environment prior to starting a network and do some cleanup after
the network has been shut down. Consider all the functionality that
libvirt doesn't currently have as an example what a hook script can
possibly do.

Signed-off-by: Michal Privoznik <mprivozn@redhat.com>
(cherry picked from commit f1ab06e43da7a892b499479aa7a7f9407fc0d917)

Conflicts:
	src/lxc/lxc_driver.c:
	src/network/bridge_driver.c:
	src/network/bridge_driver.h:
	src/qemu/qemu_command.c:
	src/qemu/qemu_hotplug.c:
	src/qemu/qemu_process.c: Well, a lot of patches is missing.
Signed-off-by: Jiri Denemark <jdenemar@redhat.com>
---
 docs/hooks.html.in          | 96 ++++++++++++++++++++++++++++++++++++++-------
 src/lxc/lxc_process.c       |  6 +--
 src/network/bridge_driver.c | 91 ++++++++++++++++++++++++++++++++++++++++--
 src/network/bridge_driver.h | 21 +++++-----
 src/qemu/qemu_command.c     |  2 +-
 src/qemu/qemu_hotplug.c     | 14 +++----
 src/qemu/qemu_process.c     |  4 +-
 src/util/hooks.c            | 13 +++++-
 src/util/hooks.h            | 11 ++++++
 9 files changed, 217 insertions(+), 41 deletions(-)

diff --git a/docs/hooks.html.in b/docs/hooks.html.in
index 5f9963d..731c6f3 100644
--- a/docs/hooks.html.in
+++ b/docs/hooks.html.in
@@ -12,9 +12,15 @@
        actions occur:</p>
     <ul>
       <li>The libvirt daemon starts, stops, or reloads its
-          configuration<br/><br/></li>
-      <li>A QEMU guest is started or stopped<br/><br/></li>
-      <li>An LXC guest is started or stopped<br/><br/></li>
+          configuration
+          (<span class="since">since 0.8.0</span>)<br/><br/></li>
+      <li>A QEMU guest is started or stopped
+         (<span class="since">since 0.8.0</span>)<br/><br/></li>
+         <li>An LXC guest is started or stopped
+         (<span class="since">since 0.8.0</span>)<br/><br/></li>
+      <li>A network is started or stopped or an interface is
+          plugged/unplugged to/from the network
+          (<span class="since">since 1.2.2</span>)<br/><br/></li>
     </ul>
 
     <h2><a name="location">Script location</a></h2>
@@ -43,6 +49,9 @@
           Executed when a QEMU guest is started, stopped, or migrated<br/><br/></li>
       <li><code>/etc/libvirt/hooks/lxc</code><br /><br/>
           Executed when an LXC guest is started or stopped</li>
+      <li><code>/etc/libvirt/hooks/network</code><br/><br/>
+          Executed when a network is started or stopped or an
+          interface is plugged/unplugged to/from the network</li>
     </ul>
     <br/>
 
@@ -65,6 +74,39 @@
        XML description for the domain on their stdin. This includes items
        such the UUID of the domain and its storage information, and is
        intended to provide all the libvirt information the script needs.</p>
+    <p>For all cases, stdin of the network hook script is provided with the
+       full XML description of the network status in the following form:</p>
+
+<pre>&lt;hookData&gt;
+  &lt;network&gt;
+     &lt;name&gt;$network_name&lt;/name&gt;
+     &lt;uuid&gt;afca425a-2c3a-420c-b2fb-dd7b4950d722&lt;/uuid&gt;
+     ...
+  &lt;/network&gt;
+&lt;/hookData&gt;</pre>
+
+    <p>In the case of an interface
+       being plugged/unplugged to/from the network, the network XML will be
+       followed with the full XML description of the domain containing the
+       interface that is being plugged/unplugged:</p>
+
+<pre>&lt;hookData&gt;
+  &lt;network&gt;
+     &lt;name&gt;$network_name&lt;/name&gt;
+     &lt;uuid&gt;afca425a-2c3a-420c-b2fb-dd7b4950d722&lt;/uuid&gt;
+     ...
+  &lt;/network&gt;
+  &lt;domain type='$domain_type' id='$domain_id'&gt;
+     &lt;name&gt;$domain_name&lt;/name&gt;
+     &lt;uuid&gt;afca425a-2c3a-420c-b2fb-dd7b4950d722&lt;/uuid&gt;
+     ...
+  &lt;/domain&gt;
+&lt;/hookData&gt;</pre>
+
+    <p>Please note that this approach is different from other cases such as
+       <code>daemon</code>, <code>qemu</code> or <code>lxc</code> hook scripts,
+       because two XMLs may be passed here, while in the other cases only a single
+       XML is passed.</p>
 
     <p>The command line arguments take this approach:</p>
     <ol>
@@ -180,25 +222,49 @@
         <pre>/etc/libvirt/hooks/lxc guest_name reconnect begin -</pre>
       </li>
     </ul>
+
+    <h5><a name="network">/etc/libvirt/hooks/network</a></h5>
+    <ul>
+      <li><span class="since">Since 1.2.2</span>, before a network is started,
+        this script is called as:<br/>
+          <pre>/etc/libvirt/hooks/network network_name start begin -</pre></li>
+      <li>After the network is started, up &and; running, the script is
+        called as:<br/>
+          <pre>/etc/libvirt/hooks/network network_name started begin -</pre></li>
+      <li>When a network is shut down, this script is called as:<br/>
+          <pre>/etc/libvirt/hooks/network network_name stopped end -</pre></li>
+      <li>Later, when network is started and there's an interface from a
+        domain to be plugged into the network, the hook script is called as:<br/>
+          <pre>/etc/libvirt/hooks/network network_name plugged begin -</pre>
+        Please note, that in this case, the script is passed both network and
+        domain XMLs on its stdin.</li>
+      <li>When the domain from previous case is shutting down, the interface
+        is unplugged. This leads to another script invocation:<br/>
+          <pre>/etc/libvirt/hooks/network network_name unplugged begin -</pre>
+        And again, as in previous case, both network and domain XMLs are passed
+        onto script's stdin.</li>
+    </ul>
+
     <br/>
 
     <h2><a name="execution">Script execution</a></h2>
     <ul>
-      <li>The "start" operation for the guest hook scripts, qemu and lxc,
-          executes <b>prior</b> to the guest being created.  This allows the
-          guest start operation to be aborted if the script returns indicating
-          failure.<br/><br/></li>
-      <li>The "shutdown" operation for the guest hook scripts, qemu and lxc,
-          executes <b>after</b> the guest has stopped.  If the hook script
-          indicates failure in its return, the shut down of the guest cannot
-          be aborted because it has already been performed.<br/><br/></li>
+      <li>The "start" operation for the guest and network hook scripts,
+          executes <b>prior</b> to the object (guest or network) being created.
+          This allows the object start operation to be aborted if the script
+          returns indicating failure.<br/><br/></li>
+      <li>The "shutdown" operation for the guest and network hook scripts,
+          executes <b>after</b> the object (guest or network) has stopped. If
+          the hook script indicates failure in its return, the shut down of the
+          object cannot be aborted because it has already been performed.
+          <br/><br/></li>
       <li>Hook scripts execute in a synchronous fashion.  Libvirt waits
           for them to return before continuing the given operation.<br/><br/>
-          This is most noticeable with the guest start operation, as a lengthy
-          operation in the hook script can mean an extended wait for the guest
-          to be available to end users.<br/><br/></li>
+          This is most noticeable with the guest or network start operation,
+          as a lengthy operation in the hook script can mean an extended wait
+          for the guest or network to be available to end users.<br/><br/></li>
       <li>For a hook script to be utilised, it must have its execute bit set
-          (ie. chmod o+rx <i>qemu</i>), and must be present when the libvirt
+          (e.g. chmod o+rx <i>qemu</i>), and must be present when the libvirt
           daemon is started.<br/><br/></li>
       <li>If a hook script is added to a host after the libvirt daemon is
           already running, it won't be used until the libvirt daemon
diff --git a/src/lxc/lxc_process.c b/src/lxc/lxc_process.c
index 63257f6..dc196cd 100644
--- a/src/lxc/lxc_process.c
+++ b/src/lxc/lxc_process.c
@@ -263,7 +263,7 @@ static void virLXCProcessCleanup(virLXCDriverPtr driver,
                                 iface->ifname));
             ignore_value(virNetDevVethDelete(iface->ifname));
         }
-        networkReleaseActualDevice(iface);
+        networkReleaseActualDevice(vm->def, iface);
     }
 
     virDomainConfVMNWFilterTeardown(vm);
@@ -449,7 +449,7 @@ static int virLXCProcessSetupInterfaces(virConnectPtr conn,
          * network's pool of devices, or resolve bridge device name
          * to the one defined in the network definition.
          */
-        if (networkAllocateActualDevice(def->nets[i]) < 0)
+        if (networkAllocateActualDevice(def, def->nets[i]) < 0)
             goto cleanup;
 
         switch (virDomainNetGetActualType(def->nets[i])) {
@@ -553,7 +553,7 @@ cleanup:
                 ignore_value(virNetDevOpenvswitchRemovePort(
                                 virDomainNetGetActualBridgeName(iface),
                                 iface->ifname));
-            networkReleaseActualDevice(iface);
+            networkReleaseActualDevice(def, iface);
         }
     }
     return ret;
diff --git a/src/network/bridge_driver.c b/src/network/bridge_driver.c
index b29db37..d7f0354 100644
--- a/src/network/bridge_driver.c
+++ b/src/network/bridge_driver.c
@@ -65,6 +65,7 @@
 #include "virnetdevtap.h"
 #include "virnetdevvportprofile.h"
 #include "virdbus.h"
+#include "hooks.h"
 
 #define NETWORK_PID_DIR LOCALSTATEDIR "/run/libvirt/network"
 #define NETWORK_STATE_DIR LOCALSTATEDIR "/lib/libvirt/network"
@@ -122,6 +123,51 @@ static void networkRefreshDaemons(struct network_driver *driver);
 
 static struct network_driver *driverState = NULL;
 
+static int
+networkRunHook(virNetworkObjPtr network,
+               virDomainDefPtr dom,
+               int op,
+               int sub_op)
+{
+    virBuffer buf = VIR_BUFFER_INITIALIZER;
+    char *xml = NULL, *net_xml = NULL, *dom_xml = NULL;
+    int hookret;
+    int ret = -1;
+
+    if (virHookPresent(VIR_HOOK_DRIVER_NETWORK)) {
+        virBufferAddLit(&buf, "<hookData>\n");
+        virBufferAdjustIndent(&buf, 2);
+        if (virNetworkDefFormatBuf(&buf, network->def, 0) < 0)
+            goto cleanup;
+        if (dom && virDomainDefFormatInternal(dom, 0, &buf) < 0)
+            goto cleanup;
+
+        virBufferAdjustIndent(&buf, -2);
+        virBufferAddLit(&buf, "</hookData>");
+
+        if (virBufferError(&buf) ||
+            !(xml = virBufferContentAndReset(&buf)))
+            goto cleanup;
+
+        hookret = virHookCall(VIR_HOOK_DRIVER_NETWORK, network->def->name,
+                              op, sub_op, NULL, xml, NULL);
+
+        /*
+         * If the script raised an error, pass it to the callee.
+         */
+        if (hookret < 0)
+            goto cleanup;
+    }
+
+    ret = 0;
+cleanup:
+    virBufferFreeAndReset(&buf);
+    VIR_FREE(xml);
+    VIR_FREE(net_xml);
+    VIR_FREE(dom_xml);
+    return ret;
+}
+
 static char *
 networkDnsmasqLeaseFileNameDefault(const char *netname)
 {
@@ -2409,6 +2455,13 @@ networkStartNetwork(struct network_driver *driver,
     if (virNetworkObjSetDefTransient(network, true) < 0)
         goto cleanup;
 
+    /* Run an early hook to set-up missing devices.
+     * If the script raised an error abort the launch. */
+    if (networkRunHook(network, NULL,
+                       VIR_HOOK_NETWORK_OP_START,
+                       VIR_HOOK_SUBOP_BEGIN) < 0)
+        goto cleanup;
+
     switch (network->def->forwardType) {
 
     case VIR_NETWORK_FORWARD_NONE:
@@ -2428,6 +2481,12 @@ networkStartNetwork(struct network_driver *driver,
         break;
     }
 
+    /* finally we can call the 'started' hook script if any */
+    if (networkRunHook(network, NULL,
+                       VIR_HOOK_NETWORK_OP_STARTED,
+                       VIR_HOOK_SUBOP_BEGIN) < 0)
+        goto cleanup;
+
     /* Persist the live configuration now that anything autogenerated
      * is setup.
      */
@@ -2487,6 +2546,10 @@ static int networkShutdownNetwork(struct network_driver *driver,
         break;
     }
 
+    /* now that we know it's stopped call the hook if present */
+    networkRunHook(network, NULL, VIR_HOOK_NETWORK_OP_STOPPED,
+                   VIR_HOOK_SUBOP_END);
+
     network->active = 0;
     virNetworkObjUnsetDefTransient(network);
     return ret;
@@ -3504,6 +3567,7 @@ finish:
 }
 
 /* networkAllocateActualDevice:
+ * @dom: domain definition that @iface belongs to
  * @iface: the original NetDef from the domain
  *
  * Looks up the network reference by iface, allocates a physical
@@ -3515,7 +3579,8 @@ finish:
  * Returns 0 on success, -1 on failure.
  */
 int
-networkAllocateActualDevice(virDomainNetDefPtr iface)
+networkAllocateActualDevice(virDomainDefPtr dom,
+                            virDomainNetDefPtr iface)
 {
     struct network_driver *driver = driverState;
     enum virDomainNetType actualType = iface->type;
@@ -3846,6 +3911,12 @@ validate:
         }
     }
 
+    /* finally we can call the 'plugged' hook script if any */
+    if (networkRunHook(network, dom,
+                       VIR_HOOK_NETWORK_OP_IFACE_PLUGGED,
+                       VIR_HOOK_SUBOP_BEGIN) < 0)
+        goto error;
+
     if (dev) {
         /* we are now assured of success, so mark the allocation */
         dev->connections++;
@@ -3881,6 +3952,7 @@ error:
 }
 
 /* networkNotifyActualDevice:
+ * @dom: domain definition that @iface belongs to
  * @iface:  the domain's NetDef with an "actual" device already filled in.
  *
  * Called to notify the network driver when libvirtd is restarted and
@@ -3891,7 +3963,8 @@ error:
  * Returns 0 on success, -1 on failure.
  */
 int
-networkNotifyActualDevice(virDomainNetDefPtr iface)
+networkNotifyActualDevice(virDomainDefPtr dom,
+                          virDomainNetDefPtr iface)
 {
     struct network_driver *driver = driverState;
     enum virDomainNetType actualType = virDomainNetGetActualType(iface);
@@ -4043,6 +4116,11 @@ networkNotifyActualDevice(virDomainNetDefPtr iface)
     }
 
 success:
+    /* finally we can call the 'plugged' hook script if any */
+    if (networkRunHook(network, dom, VIR_HOOK_NETWORK_OP_IFACE_PLUGGED,
+                       VIR_HOOK_SUBOP_BEGIN) < 0)
+        goto error;
+
     netdef->connections++;
     VIR_DEBUG("Using network %s, %d connections",
               netdef->name, netdef->connections);
@@ -4058,6 +4136,7 @@ error:
 
 
 /* networkReleaseActualDevice:
+ * @dom: domain definition that @iface belongs to
  * @iface:  a domain's NetDef (interface definition)
  *
  * Given a domain <interface> element that previously had its <actual>
@@ -4068,7 +4147,8 @@ error:
  * Returns 0 on success, -1 on failure.
  */
 int
-networkReleaseActualDevice(virDomainNetDefPtr iface)
+networkReleaseActualDevice(virDomainDefPtr dom,
+                           virDomainNetDefPtr iface)
 {
     struct network_driver *driver = driverState;
     enum virDomainNetType actualType = virDomainNetGetActualType(iface);
@@ -4179,6 +4259,11 @@ networkReleaseActualDevice(virDomainNetDefPtr iface)
 
 success:
     netdef->connections--;
+
+    /* finally we can call the 'unplugged' hook script if any */
+    networkRunHook(network, dom, VIR_HOOK_NETWORK_OP_IFACE_UNPLUGGED,
+                   VIR_HOOK_SUBOP_BEGIN);
+
     VIR_DEBUG("Releasing network %s, %d connections",
               netdef->name, netdef->connections);
     ret = 0;
diff --git a/src/network/bridge_driver.h b/src/network/bridge_driver.h
index 3af74a1..8ffeaff 100644
--- a/src/network/bridge_driver.h
+++ b/src/network/bridge_driver.h
@@ -36,12 +36,15 @@
 int networkRegister(void);
 
 # if WITH_NETWORK
-int networkAllocateActualDevice(virDomainNetDefPtr iface)
-    ATTRIBUTE_NONNULL(1);
-int networkNotifyActualDevice(virDomainNetDefPtr iface)
-    ATTRIBUTE_NONNULL(1);
-int networkReleaseActualDevice(virDomainNetDefPtr iface)
-    ATTRIBUTE_NONNULL(1);
+int networkAllocateActualDevice(virDomainDefPtr dom,
+                                virDomainNetDefPtr iface)
+    ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2);
+int networkNotifyActualDevice(virDomainDefPtr dom,
+                              virDomainNetDefPtr iface)
+    ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2);
+int networkReleaseActualDevice(virDomainDefPtr dom,
+                               virDomainNetDefPtr iface)
+    ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2);
 
 int networkGetNetworkAddress(const char *netname, char **netaddr)
     ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2);
@@ -53,9 +56,9 @@ int networkBuildDhcpDaemonCommandLine(virNetworkObjPtr network,
     ;
 # else
 /* Define no-op replacements that don't drag in any link dependencies.  */
-#  define networkAllocateActualDevice(iface) 0
-#  define networkNotifyActualDevice(iface) 0
-#  define networkReleaseActualDevice(iface) 0
+#  define networkAllocateActualDevice(dom, iface) 0
+#  define networkNotifyActualDevice(iface) (iface=iface, 0)
+#  define networkReleaseActualDevice(dom, iface) (dom=dom, iface=iface, 0)
 #  define networkGetNetworkAddress(netname, netaddr) (-2)
 #  define networkBuildDhcpDaemonCommandLine(network, cmdout, pidfile, dctx, caps) 0
 # endif
diff --git a/src/qemu/qemu_command.c b/src/qemu/qemu_command.c
index d1d7d11..e9a1cb9 100644
--- a/src/qemu/qemu_command.c
+++ b/src/qemu/qemu_command.c
@@ -6208,7 +6208,7 @@ qemuBuildCommandLine(virConnectPtr conn,
              * network's pool of devices, or resolve bridge device name
              * to the one defined in the network definition.
              */
-            if (networkAllocateActualDevice(net) < 0)
+            if (networkAllocateActualDevice(def, net) < 0)
                goto error;
 
             actualType = virDomainNetGetActualType(net);
diff --git a/src/qemu/qemu_hotplug.c b/src/qemu/qemu_hotplug.c
index c9f8a5c..8d13741 100644
--- a/src/qemu/qemu_hotplug.c
+++ b/src/qemu/qemu_hotplug.c
@@ -667,8 +667,8 @@ int qemuDomainAttachNetDevice(virConnectPtr conn,
      * network's pool of devices, or resolve bridge device name
      * to the one defined in the network definition.
      */
-    if (networkAllocateActualDevice(net) < 0)
-        return -1;
+    if (networkAllocateActualDevice(vm->def, net) < 0)
+        goto cleanup;
 
     actualType = virDomainNetGetActualType(net);
 
@@ -870,7 +870,7 @@ cleanup:
 
         virDomainNetRemoveHostdev(vm->def, net);
 
-        networkReleaseActualDevice(net);
+        networkReleaseActualDevice(vm->def, net);
     }
 
     VIR_FREE(nicstr);
@@ -1510,7 +1510,7 @@ qemuDomainChangeNet(struct qemud_driver *driver,
      * free it if we fail for any reason
      */
     if (newdev->type == VIR_DOMAIN_NET_TYPE_NETWORK &&
-        networkAllocateActualDevice(newdev) < 0) {
+        networkAllocateActualDevice(vm->def, newdev) < 0) {
         goto cleanup;
     }
 
@@ -1688,7 +1688,7 @@ qemuDomainChangeNet(struct qemud_driver *driver,
 
         /* this function doesn't work with HOSTDEV networks yet, thus
          * no need to change the pointer in the hostdev structure */
-        networkReleaseActualDevice(olddev);
+        networkReleaseActualDevice(vm->def, olddev);
         virDomainNetDefFree(olddev);
         /* move newdev into the nets list, and NULL it out from the
          * virDomainDeviceDef that we were given so that the caller
@@ -1720,7 +1720,7 @@ cleanup:
      * replace the entire device object.
      */
     if (newdev)
-        networkReleaseActualDevice(newdev);
+        networkReleaseActualDevice(vm->def, newdev);
 
     return ret;
 }
@@ -2611,7 +2611,7 @@ qemuDomainDetachNetDevice(struct qemud_driver *driver,
     ret = 0;
 cleanup:
     if (!ret) {
-        networkReleaseActualDevice(detach);
+        networkReleaseActualDevice(vm->def, detach);
         virDomainNetRemove(vm->def, detachidx);
         virDomainNetDefFree(detach);
     }
diff --git a/src/qemu/qemu_process.c b/src/qemu/qemu_process.c
index 64eea03..e439010 100644
--- a/src/qemu/qemu_process.c
+++ b/src/qemu/qemu_process.c
@@ -2933,7 +2933,7 @@ qemuProcessNotifyNets(virDomainDefPtr def)
 
     for (ii = 0 ; ii < def->nnets ; ii++) {
         virDomainNetDefPtr net = def->nets[ii];
-        if (networkNotifyActualDevice(net) < 0)
+        if (networkNotifyActualDevice(def, net) < 0)
             return -1;
     }
     return 0;
@@ -4470,7 +4470,7 @@ void qemuProcessStop(struct qemud_driver *driver,
 
         /* kick the device out of the hostdev list too */
         virDomainNetRemoveHostdev(def, net);
-        networkReleaseActualDevice(net);
+        networkReleaseActualDevice(vm->def, net);
     }
 
 retry:
diff --git a/src/util/hooks.c b/src/util/hooks.c
index f5890d2..8f70580 100644
--- a/src/util/hooks.c
+++ b/src/util/hooks.c
@@ -48,12 +48,14 @@ VIR_ENUM_DECL(virHookDaemonOp)
 VIR_ENUM_DECL(virHookSubop)
 VIR_ENUM_DECL(virHookQemuOp)
 VIR_ENUM_DECL(virHookLxcOp)
+VIR_ENUM_DECL(virHookNetworkOp)
 
 VIR_ENUM_IMPL(virHookDriver,
               VIR_HOOK_DRIVER_LAST,
               "daemon",
               "qemu",
-              "lxc")
+              "lxc",
+              "network")
 
 VIR_ENUM_IMPL(virHookDaemonOp, VIR_HOOK_DAEMON_OP_LAST,
               "start",
@@ -83,6 +85,13 @@ VIR_ENUM_IMPL(virHookLxcOp, VIR_HOOK_LXC_OP_LAST,
               "started",
               "reconnect")
 
+VIR_ENUM_IMPL(virHookNetworkOp, VIR_HOOK_NETWORK_OP_LAST,
+              "start",
+              "started",
+              "stopped",
+              "plugged",
+              "unplugged")
+
 static int virHooksFound = -1;
 
 /**
@@ -246,6 +255,8 @@ virHookCall(int driver,
         case VIR_HOOK_DRIVER_LXC:
             opstr = virHookLxcOpTypeToString(op);
             break;
+        case VIR_HOOK_DRIVER_NETWORK:
+            opstr = virHookNetworkOpTypeToString(op);
     }
     if (opstr == NULL) {
         virReportError(VIR_ERR_INTERNAL_ERROR,
diff --git a/src/util/hooks.h b/src/util/hooks.h
index 0ca376f..7c3ba92 100644
--- a/src/util/hooks.h
+++ b/src/util/hooks.h
@@ -31,6 +31,7 @@ enum virHookDriverType {
     VIR_HOOK_DRIVER_DAEMON = 0,        /* Daemon related events */
     VIR_HOOK_DRIVER_QEMU,              /* QEmu domains related events */
     VIR_HOOK_DRIVER_LXC,               /* LXC domains related events */
+    VIR_HOOK_DRIVER_NETWORK,           /* network related events */
 
     VIR_HOOK_DRIVER_LAST,
 };
@@ -75,6 +76,16 @@ enum virHookLxcOpType {
     VIR_HOOK_LXC_OP_LAST,
 };
 
+enum virHookNetworkOpType {
+    VIR_HOOK_NETWORK_OP_START,          /* network is about to start */
+    VIR_HOOK_NETWORK_OP_STARTED,        /* network has start */
+    VIR_HOOK_NETWORK_OP_STOPPED,        /* network has stopped */
+    VIR_HOOK_NETWORK_OP_IFACE_PLUGGED,  /* an interface has been plugged into the network */
+    VIR_HOOK_NETWORK_OP_IFACE_UNPLUGGED,    /* an interface was unplugged from the network */
+
+    VIR_HOOK_NETWORK_OP_LAST,
+};
+
 int virHookInitialize(void);
 
 int virHookPresent(int driver);
-- 
1.9.3

